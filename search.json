[{"title":"Git相关（一）","url":"/2021/09/25/Git%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/","content":"GitGit的使用Git使用前的配置\n配置提交人姓名 git config –global user.name  提交人姓名\n配置提交人邮箱  git config –global user.name 提交人邮箱\n查看 git 配置信息 git config –list\n\n注意\n\n如果要对配置信息进行修改，重复上面命令即可\n配置只需要执行一次\n\n提交步骤\ngit init 初始化 git 仓库\n\ngit status 查看文件状态\n\ngit add 文件列表 追踪文件\n\ngit commit -m 提交信息 向仓库中提交代码\n\ngit log 查看提交记录\n//第一次提交git init //初始化仓库操作git add . //将文件暂存到本地git commit -m &#x27;你需要填写的信息&#x27; //‘’中可以是中文git remote add origin `````   //你的仓库地址  在新建仓库是会有提示git push -u origin main //在GitHub中新建的仓库默认的分支是main 在Gitee中新建的仓库分支是master 这些在你新建仓库的时候都会有//若是想要提交到新建的分支可以新建分支git branch 分支名git checkout 你新建的分支名 //切换到新建的分支//若是第一次提交输入git remote add origin `````//若是后续开发所需要得到提交git push -u origin 你所要提交的分支名\n\n撤销\n用暂存区中的文件覆盖工作目录的文件 git checkout 文件\n将文件从暂存区中删除 git rm –cached 文件\n将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录  git reset –hard commitID\n\n分支\n为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。\n使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。\n\n分支细分\n主分支( master ) ：第一次向 git 仓库中提交更新记录时会自动产生的一个分支\n\n开发分支( develop )：作为开发的分支，基于 master 分支创建\n\n功能分支( feature )：作为开发具体功能的分支，基于开发分支创建\n\n\n功能分支 -&gt; 开发分支 -&gt; 主分支\n分支命令\ngit branch 查看分支\ngit branch 分支名称 创建分支\ngit checkout 分支名称 切换分支\ngit merge 来源分支 合并分支\ngit branch -d 分支名称 删除分支 （分支被合并后才允许删除）（-D 强制删除）\n\n暂时保存\n在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本\n\n临时转向其他工作。\n\n存储临时改动:  git stash\n恢复改动:  git stash pop\n\n","categories":["Git"],"tags":["Git"]},{"title":"Laravel学习（一）","url":"/2021/09/25/Laravel%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"Laravel5.7一、使用Git Clone将项目复制到新的开发环境中1.首先在原始文件夹中（假设现在使用的master分支）我们需要推送项目到Git中\n//以码云为例 网址：http://gitee.comgit add . //将代码暂存到本地仓库git commit -m &#x27;初始化本地仓库&#x27;//提交信息gti remote add origin https://gitee.com/user/entrepot.git   //entrepot是仓库的意思 //user则为用户在gitee的用户名git push -u origin master\n\n2.从Gitee上复制下来项目\ngit clone https://gitee.com/user/entrepot.git\n\n3.接下来我们需要进行composer install来解决dependencies：\ncomposer install\n\n4.完成后，我们需要建立.env文件，因为.env默认是gitee所忽略的文件：\ncp .env.example .env\n\n5.因为env.example中默认没有app key，所以我们在.env中生成新的app key：\nphp artisan key:generate\n\n6.修改.env文件\nDB_CONNECTION=mysql //链接数据库DB_HOST=10.10.102.92 //IP地址DB_PORT=3306 //数据库端口号DB_DATABASE=webshop //数据库名称DB_USERNAME=root //数据库用户名DB_PASSWORD=root //数据库密码\n\n7.保存后，运行\nphp artsian migrate\n\n\n\n二、app==&gt;Http==&gt;主要为控制器的存放\n新建控制器的命令为:\nphp artisan make:controller PhpController//在控制器的跟目录下新建一个控制器\n\n\n\nphp artsian make:controller filer/PhpController //在指定文件目录下新建一个控制器\n\n三、resources==&gt;views(为视图存放目录,界面显示)新建的视图后缀名需要是 index.blade.php\n主页页面结构：\n@extends(&#x27;frame&#x27;)//frame为继承模板@section(&#x27;style&#x27;)//引入的style的样式@endsection@section(&#x27;content&#x27;)//界面主要内容@endsection@section(&#x27;script&#x27;)//js脚本@endsection\n\n四、引入外部js文件的方式在project==》public ==》 js(文件顺序)\n@section(&#x27;script&#x27;)//js脚本\t&lt;scritp src=&quot;&#123;&#123;URL::asset(js/javascritp.js)&#125;&#125;&quot;&gt;&lt;/script&gt;//举例    &lt;scritp src=&quot;http://xxx.xxx.xxx&quot;&gt;&lt;/script&gt;//根据网址引入的js@endsection//css的引入方法大致同上\n\n五、主界面点击模块跳转到对应的页面project==&gt;routes==&gt;web.php\nRoute::prefix(&#x27;/admin&#x27;)-&gt;group(function()&#123; //成组\tRoute::get(&#x27;/shoplist&#x27;,function()&#123; \t\treturn view(&#x27;shoplist&#x27;);//返回对应的视图\t&#125;)-&gt;name(&#x27;shoplist&#x27;);&#125;)\n\n模板frome的跳转方法\n//在模板下写入&lt;ul&gt;    &lt;li class=&quot;&lt;?php        if(stripos($_SERVER[&#x27;REQUSET_URI&#x27;],&#x27;admin/shoplist&#x27;) != false) echo &#x27;active&#x27;?&gt;&quot;&gt;    \t&lt;a href=&quot;/admin/shoplist&quot;&gt;   \t\t\t商品信息        &lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;\n\n六、在phpstudy_pro中搭建网站环境的注意项：在project==》public==》.htaccess\n1.首先复制一份.htaccess文件\n2.在phpstudy中搭建网址:\nwww.shoppping.com:80 //默认端口为80端口，若修改在进入浏览器之后则需要在网址后缀中添加所修改的端口号//搭建网址的目录中不可汉中文\n\n3.再次打开.htaccess文件 将复制的.htaccess文件中的内容重新复制到.htaccess文件中\n","categories":["Laravel"],"tags":["Laravel"]},{"title":"JavaScriptES6（day1）","url":"/2021/10/02/JavaScriptES6%EF%BC%88day1%EF%BC%89/","content":"const关键字const关键字用于定义常量（一旦定义无法改变的变量，通常是表示一些固定不变的数据）\n使用const 的特点\n\n无法修改\n\n 支持块作用域\n\n 无法重复定义\n\n 无法声明前置\n\n 不能被windows挂载\n\n不能作为for循环体中的变量使用\n\n值只能是值类型，如果是引用类型则可以被修改\n\n示例：\nconst number = 42;try &#123;  number = 99;&#125; catch (err) &#123;  console.log(err);  // expected output: TypeError: invalid assignment to const `number&#x27;  // Note - error messages will vary depending on browser&#125;console.log(number);// expected output: 42\n\n语法：const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];//nameN//常量名称，可以是任意合法的标识符。//valueN//常量值，可以是任意合法的表达式。\n\n描述此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为 window 对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。\n**const**声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。\n关于“暂存死区”的所有讨论都适用于let和const。\n一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。\n示例：基本用法：// 定义常量MY_FAV并赋值7const MY_FAV = 7;// 报错 - Uncaught TypeError: Assignment to constant variable.MY_FAV = 20;// MY_FAV is 7console.log(&#x27;my favorite number is: &#x27; + MY_FAV);// 尝试重新声明会报错// Uncaught SyntaxError: Identifier &#x27;MY_FAV&#x27; has already been declaredconst MY_FAV = 20;// MY_FAV 保留给上面的常量，这个操作会失败var MY_FAV = 20;// 也会报错let MY_FAV = 20;\n\n块作用域：注意块作用域的性质很重要\nif (MY_FAV === 7) &#123;  // 没问题，并且创建了一个块作用域变量 MY_FAV  // (works equally well with let to declare a block scoped non const variable)  let MY_FAV = 20  // MY_FAV 现在为 20  console.log(&#x27;my favorite number is &#x27; + MY_FAV);  // 这被提升到全局上下文并引发错误  var MY_FAV = 20;&#125;// MY_FAV 依旧为7console.log(&#x27;my favorite number is &#x27; + MY_FAV);\n\n常量需要一个初始值// 报错// Uncaught SyntaxError: Missing initializer in const declarationconst FOO;\n\n常量可以定义为对象或者数组：const MY_OBJECT = &#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;;// 重写对象和上面一样会失败// Uncaught TypeError: Assignment to constant variable.MY_OBJECT = &#123;&#x27;OTHER_KEY&#x27;: &#x27;value&#x27;&#125;;// 对象属性并不在保护的范围内// 下面这个声明会成功执行MY_OBJECT.key = &#x27;otherValue&#x27;; // Use Object.freeze() to make object immutable// 也可以用来定义数组const MY_ARRAY = [];// 可以向数组填充数据MY_ARRAY.push(&#x27;A&#x27;); // [&quot;A&quot;]// 但是，将一个新数组赋给变量会引发错误// Uncaught TypeError: Assignment to constant variable.MY_ARRAY = [&#x27;B&#x27;];\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"Laravel问题（一）","url":"/2021/09/25/Laravel%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/","content":"composer创建laravel项目报错问题\n\n若显示如图的报错信息，则需要更换composer镜像源\n之前用的是composer中国镜像，地址：\nhttps://pkg.phpcomposer.com/#how-to-install-composer\n\n换成阿里镜像后成功创建laravel项目\n\n阿里镜像地址：\nhttps://developer.aliyun.com/article/726948spm=a2c6h.14164896.0.0.6f8a791fPW7fDO\n\n阿里镜像（切换）\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n切换之后可以使用\ncomposer config -gl\n\n来查看镜像地址\n\n注：切换镜像需要安装composer\n","categories":["Laravel"],"tags":["Laravel"]},{"title":"Vue基础","url":"/2021/09/25/Vue%E5%9F%BA%E7%A1%80/","content":"Vue简介\nJavaScript框架\n简化DOM操作\n响应式数据驱动\n\nVue指令\nv-text   设置标签的文本值( textContent )\nv-html  设置标签的innerHTML（就是文本里面可以包含html标签）\nv-on 为元素绑定事件  不用加 on\n\n   \t\t&lt;!-- 可以使用@click=&quot;click&quot;  --&gt;  &lt;input type=&quot;button&quot; value=&quot;事件绑定 v-on&quot; v-on:click=&quot;click&quot; id=&quot;app&quot;&gt;  var app = new Vue(&#123;   el: &#x27;#app&#x27;,   data:&#123;   \tclick: function () &#123;       console.log(&#x27;ok&#x27;);    &#125;,   &#125;&#125;)      \n\n\nv-show 根据表达值得真假，切换元素的显示和隐藏\n\n&lt;div id=&quot;app&quot;&gt;&lt;img src=&quot;&quot; v-show=&quot;true&quot;&gt;    &lt;img src=&quot;&quot; v-show=&quot;isShow&quot;&gt;    &lt;img src=&quot;&quot; v-show=&quot;age&gt;=18&quot;&gt;    &lt;/div&gt;var app = new Vue(&#123;el:&quot;#app&quot;,    data:&#123;        isShow:false,        age:18    &#125;&#125;)\n\n\nv-if  根据表达值的真假，切换元素的显示和隐藏（操作dom元素）\n\n&lt;div id=&quot;app&quot;&gt;&lt;img src=&quot;&quot; v-if=&quot;true&quot;&gt;    &lt;img src=&quot;&quot; v-if=&quot;isShow&quot;&gt;    &lt;img src=&quot;&quot; v-if=&quot;表达式&quot;&gt;    &lt;/div&gt;var app = new Vue(&#123;el:&quot;#app&quot;,    data:&#123;        isShow:false,        age:18    &#125;&#125;)\n\n\nv-bind 设置元素的属性（比如：src title calss）\n\n&lt;div id=&quot;app&quot;&gt; &lt;img v-bind:src=&quot;imgSrc&quot;&gt;    &lt;img :src=&quot;imgSrc&quot;&gt;    &lt;/div&gt;var app = new Vue(&#123;el:&quot;#app&quot;,    data:&#123;        imgSrc    &#125;&#125;)\n\n\nv-for 循环数据\n\n&lt;div id=&quot;app&quot;&gt;        &lt;ul&gt;            &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;        &lt;script&gt;    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            list: [                &#123;                    id: 0,                    name: &#x27;小花&#x27;,                    age: 15                &#125;,                &#123;                    id: 1,                    name: &#x27;李强&#x27;,                    age: 11                &#125;,                &#123;                    id: 2,                    name: &#x27;小白&#x27;,                    age: 16                &#125;,                &#123;                    id: 3,                    name: &#x27;小黑&#x27;,                    age: 12                &#125;,            ]        &#125;    &#125;)&lt;/script&gt;\n\n\nv-model 获取设置表达元素的值（双向数据绑定）\n\n&lt;div id=&quot;app&quot;&gt;        &lt;input type=&#x27;text&#x27; v-model=&#x27;message&#x27;&gt;    &lt;/div&gt;        &lt;script&gt;    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            message: &quot;你好啊&quot;        &#125;    &#125;)&lt;/script&gt;","categories":["Vue"],"tags":["Vue"]},{"title":"Let Const Var","url":"/2021/10/02/Let/","content":"Let Const Var的区别var\nvar只有函数作用域，没有块作用域，可以声明全局/局部变量（在一共函数内声明的变量，只在该函数有效）\nvar定义的变量不能跨函数访问，但是可以跨块访问！\nvar 定义的变量如果不初始化会输出undefined，但不会报错\n可以重复定义，后定义的会覆盖先定义的。\n\nvar a;console.log(a);   //undefined,定义没赋值//-----------------------------------------var a = 1;   //全局变量 第一次定义console.log(a);    // a：1function A()&#123;    a=2;    console.log(a);  //此时之前var a=1的值已经被改变    &#125;A(); //调用A方法console.log(a);   //调用A函数，a变为函数A内部修改的值：2//---------------------------------------------var b=1;var b=2;console.log(b);  //2,后面的声明覆盖了前面的声明\n\nconst\n块级作用域内有效；\nconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n对于复合类型的变量，如数组和对象，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。\n\nconst a ;//报错 定义const 之后应该立即赋值const b = 2;b = 3//const赋的值不能直接 =const names = [];names = [1,2,3] //报错，const赋的值不能直接 = \n\nlet\nlet是块级作用域，函数内部使用let定义后，对函数外部无影响\nlet定义的变量只能在块作用域中访问，不能跨块访问，更不能跨函数访问\n不能变量声明提前，否则会报错\n不能重复定义，否则会报错\n\nlet a =1;console.log(a); // 全局变量1function A()&#123;    let a = 2;    console.log(a);  //局部变量：2&#125;A();console.log(&quot;A()函数调用后，a++&quot;);  //2var b=1;&#123;    let b=2;    console.log(b);  //  2&#125;console.log(b);   //1 console.log(aaa); let aaa=1;   //会进行报错，不能变量声明提前 let p = 1; let p = 2; console.log(p);  //重复定义，会报错\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"Vue打包之后的路径问题","url":"/2021/09/26/Vue%E6%89%93%E5%8C%85%E4%B9%8B%E5%90%8E%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","content":"vue项目打包问题(脚手架版本vue-cli2)项目目录如下：项目在运行npm run build命令之后在本地打开dist文件中的index.html，显示无内容原因：1.可能是因为 router===》index中的mode：‘history’导致的错误，可以先添加注释，在进行打包，运行2.打包之后的项目路径不正确===》解决====》修改项目路径改为相对路径修改config==》index.js==》build==》assetsPubilcPath中的‘/’改为‘./’修改build==》utils.js==》ExtractTextPlugin.extract中增加一行pubilcPath:’../../‘(脚手架vue/cli3)解决@vue/cli3打包后页面空白npm run build 后放到服务器上页面显示空白vue.config.js(项目目录下)若没有vue.config.js文件新建一个即可build: &#123;// Template for index.htmlindex: path.resolve(__dirname, &#x27;../dist/index.html&#x27;),\n// PathsassetsRoot: path.resolve(__dirname, &#x27;../dist&#x27;),assetsSubDirectory: &#x27;static&#x27;,//修改之前// assetsPubilcPath:&#x27;/&#x27;,//修改之后assetsPublicPath: &#x27;./&#x27;,\n&#125;\nif (options.extract) &#123;return ExtractTextPlugin.extract(&#123;use: loaders,fallback: &#x27;vue-style-loader&#x27;,publicPath:&#x27;../../&#x27;&#125;)&#125; else &#123;return [&#x27;vue-style-loader&#x27;].concat(loaders)&#125;\nmodule.exports = &#123;publicPath: &#x27;./&#x27;,  //输出的根路径 默认是/ 如果你的网站是app.com/vue 这更改此配置项&#125;\n\n路由模式采用hash模式（路由的默认模式）import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;\nVue.use(VueRouter)\nconst routes = []\nconst router = new VueRouter(&#123;routes,// mode: &#x27;history&#x27;&#125;)\nexport default router\n\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"Hello World","url":"/2021/09/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"前端基础Day（一）","url":"/2021/09/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80Day%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前端Day1[TOC]\n前端的五个阶段第一阶段：网页实现 html+css\n​    html+css+photoshop：页面的简单制作\n​    css进阶 复杂页面的实现\n​    企业级页面的快速构建 sass+bootstrap\n​    做网站\n第二阶段：Javascript基础以及数据交互\n​    目的：有交互的做真实的带数据的网站\n第三阶段：JavaScript进阶+node（后台）+webpack+mongodb（数据库）\n​    可以独立完成项目的开发\n第四阶段：vue+微信小程序\n第五阶段：Recat+Recat native 扩展 typescript flutter\n项目的流程（Photoshop）确定需求并进行分析\n​    产品经理或老板根据原始需求设计出原型图（UI）。不断的修改以满足客户的需求，最终根据需求生成保证原图。\n根据原生图设计出psd格式的原型稿（UI）\n​    psd是ps的专属格式，psd格式的文件能够反映出一个页面的所有元素，包括文字字体，图片的大小，颜色等所有的信息。\n前端：把所有的页面（psd的格式文件）切片转为前端工程师所需要的图片（UI或者是前端）\n前端：实现页面，完成页面功能的开发。\n后端：完成服务器端程序的开发以及数据库的开发\n测试：对功能进行测试，集成测试，压力测试，性能测试，回归测试，自动化测试，云平台测试。\n运维：上线+运维\nPhotoshop简介以及安装主要未构建位图。\n位图：有很多个像素点构成的一种图片格式。每个像素点都是个很小的小方块，一个像素点可以表达一种颜色。\n版本：cc2018\nPhotoshop工作区窗口-》工作区\n窗口-》信息\n左侧的工具栏为常用的工具\nHTML概念HTML是用于制作网页的计算机语言\n网页：用于显示网络资源的载体。网络资源可以是图片，视频，文字，音频，各种框，超链接······。\nHTML：hyper-text Markup language 超文本标记语言\n​    超文本：指网页上展示的内容，不仅仅是文本。超文本包含了图片，视频，文字，音频，各种框，超链接······。\n​    标记：用于描述超文本的代码格式，页面上的每一个超文本都有一个对应的标签来对应\nHTML基础标签&lt;a href=&quot;页面地址&quot;&gt;&lt;/a&gt; //a标签负责超链接\n\n&lt;img src=&quot;图片地址&quot; /&gt; //src负责展示的图片的地址\n\n&lt;h1-6&gt;&lt;/h1-6&gt;//标题标签\n\n&lt;p&gt;&lt;/p&gt; //段落标签\n\n&lt;br/&gt; //换行标签\n\n&amp;nbsp; //特殊符号----空格 \n\n\n\n","categories":["前端"],"tags":["前端"]},{"title":"前端基础Day（二）","url":"/2021/09/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80Day%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"前端Day2(SASS)概念：   1.css的扩展语言，本质上是脚本编程语言，通过sass所有的特点提高编写css代码的效率。即，用部分的sass代码替代之前繁琐的css代码\n\n sass底层是由面向对象的语言ruby来编写的（了解）\n\n安装：1. 先安装ruby再通过npm安装sass\n2. 使用vscode提供的插件 essay sass 快速的入手sass\n\n基础语法使用：\nsass需要放在以.sass .scss为后缀的文件之中\n\n在vscode中setting中设置sass文件转为css文件相关的配置信息\n\n```{\n//保存scss代码后转为css\n&quot;easysass.compileAfterSave&quot;: true\n//指定什么格式转为css代码\n&quot;easysass.formats&quot;:[\n    &#123;\n        &quot;format&quot;:&quot;expanded&quot;,\n        &quot;extension&quot;: &quot;css&quot;\n    &#125;,\n    &#123;\n        &quot;format&quot;:&quot;compressed&quot;,\n        &quot;extension&quot;: &quot;.min.css&quot;\n    &#125;\n],\n&quot;easysass.targetDir&quot;: &quot;css/&quot;\n\n}\n   ### 嵌套：1. 概念：可以标签样式代码里继续对其子标签设置样式2. 作用：让css代码中标签的层次更加清晰明了。解决了可能权重的问题。3. ```scss   #box&#123;   \tcolor：yellow；   \tp&#123;   \t\tcolor：blue；   \t\tspan&#123;   \t\t\tcolor：red；   \t\t&#125;   \t&#125;   &#125;   //转为css后   #box&#123;   \tcolor：yellow；   &#125;   #box p&#123;   \tcolor：blue；   &#125;   #box p span &#123;   \tcolor：red；   &#125;\n\n变量：\n概念：变量是一种存放css属性值的容器，一个变量可以保存一个样式属性值，定义的变量可以重复使用。类似于姓名。\n\n作用：解决重复样式的繁琐修改问题\n\n使用\n定义一个变量（只需要定义一次，可以多次使用）\n$变量名：css属性值；\n\n运用变量：\ncss属性名：$变量名；\n\n例子：\n//定义变量BColor=red，用于header，main，footer三个标签$BColor：red；header&#123;\tbackground-color：$BColor；&#125;main:&#123;\tbackground-color：$BColor；&#125;footer:&#123;\tbackground-color：$BColor；&#125;//转css之后header&#123;\tbackground-color：red;&#125;footer&#123;\tbackground-color：red;&#125;main&#123;\tbackground-color：red;&#125;\n定义变量的位置\n   如果需要变量整个scss文件都可以使用，就在页面的开头定义变量。\n   如果需要使用局部的变量，就在使用范围内定义变量。\n   //scss文件开头：$BColor:red;//该变量整个文件都可已使用header&#123;    $textColor:red;//该变量职能制header中使用&#125; \n变量的命名规范：\n  变量可以包含数字，字母，\n  \n  尽量不要使用数字开头\n  \n  多个单词尽量以-间隔\n\n\n\n\n\n","categories":["前端"],"tags":["前端 SASS"]},{"title":"JavaScriptES6（Day2）","url":"/2021/10/03/JavaScriptES6%EF%BC%88Day2%EF%BC%89/","content":"字符串扩展—多行字符串单行字符串：由一组单引号或者双引号定义的字符串\n单行字符串的问题：\n\n单行字符串不能换行\n一些特殊的字符串要使用转义字符\\n\n一些特殊的字符串要使用转义字符\\x20\n字符串不能直接使用嵌套\n\n单引号中不能直接写单引号，要转义\\‘ \n双引号中不能直接写双引号，要转义 \\ “\nES6为了解决单行字符串中的问题，提供了多行字符串，通过    定义，在多行字符串中，只有需要转义`，其他字符可以自由书写并且ES6多行字符串支持插值语法：${key}${}提供了js环境，因此我们可以写js表达式ES6的插值语法，让其他框架的插值语法的重要性，大打折扣\n字符穿拓展—-原始字符串在使用了转义字符串之后，并且在浏览器查看的时候，我们只能看到结果，不能看到原始完整的字符串（包含转移字符），于是在ES6中拓展了String.raw方法用于查看原始字符串\n使用方法：   Sring.raw参数通过字符串的形式进行传递，字符串中的转义字符串不会被转义\n例：let str = String.raw&#39;hello \\nic\\nkt&#39;; console.log(str); 打印出的结果就是原始的字符串hello \\nic\\nkt\n同时对于普通的字符串不让\\n生效就需要改变成 \\ \\n\n字符串拓展—重复字符串ES6中扩展了repeat方法用于重复输出字符串\n​    参数就是要重复的次数\n​    返回值就是重复的结果\n​    对原始字符串没有影响\n例：let str=&#39;hello||&#39;; console.log(str.repeat(3)); console.log(str);打印出来的结果分别就是 hello || hello || hello|| hello ||\n字符串拓展–判断字符串的位置\nstartsWith(str,pos)     是否以参数字符串开头\n\n​    截取后面的部分，并且截取位置字符\n​    str 参数字符串（子字符串）\n​    pos    字符串截取位置\n​    返回值都是bool\n​    例：let str=&quot;这是一个测试&quot;; console.log(str.startsWith(&#39;这&#39;))  return : true\n​            console.log(str.startWith(&#39;是&#39;); return : false\n\nendsWith(str,pos)    是否以字符串结尾\n\n​    截取前面的部分，并且不包含截取位置字符\n\nincludes(str,pos)     是否包含参数字符串\n\n​    截取后面的部分，并且包含截取位置字符\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"前端总结（一）","url":"/2021/11/01/%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前端总结（一）HTMLHTML的语义化就是让页面的内容格式化，优点如下：\n    1、易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。\n    2、有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。\n    3、方便其他设备解析，如盲人阅读器根据语义渲染网页\n    4、有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐\n\nHTML的语义化标签\n&lt;header&gt;&lt;/header&gt; //头部标签,用于展示自己页面的头部区域，包括网站的logo，网站的主导航···&lt;nav&gt;&lt;/nav&gt; //定义页面的导航链接的部分区域，不是所有的导航链接都需要包裹在当中&lt;main&gt;&lt;/main&gt; // main是用来存储页面的主体部分&lt;aside&gt;&lt;/aside&gt; //aside 通常用来写页面的侧边栏&lt;footer&gt;&lt;/footer&gt; //用来写页面的底部部分的信息，可以写备案号····&lt;article&gt;&lt;/article&gt; //用来定义页面的独立内容，有自己的header，footer，setions&lt;section&gt;&lt;/section&gt; //元素用于标记文档的各个部分，例如长表单文章的章节或主要部分。\n\nHTML常用标签以及属性\ninput &lt;input type=&quot;&quot;/&gt; //用户的输入框，type可以定义很多的类型 password,text,hidden,button···a &lt;a href=&quot;&quot;&gt; //a标签又被叫为链接标签，herf中可以是一个页面的地址，或者其他的地址···img  &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; //图像的标签，src中是一个图片的地址，alt中可以写当图片加载错误的时候现实的文字···h1~h6 &lt;h1-6&gt;&lt;/h1-6&gt; //页面的标题标签，h1-h6文字的大小依次递减p &lt;p&gt;&lt;/p&gt; //页面的段落标签，可以用来写文字···(一个块级标签，独占一行)span  //可以在p标签中使用，一个行内元素div //一个跨级标签，可以理解为一个大盒子，用来包裹一些东西table //表格的标签，含有border（边框），th（表头），tr（行），td（单元），col（表格的属性）ul li //无序的列表ol li //有序的列表form //表单button //按钮\n\nCSSCSS中的ID和class:在为某一标签添加样式时会使用到ID或者classCSS可以分为内联，外联，嵌套式\n内联\n在html页的标签中header中添加\n&lt;!DOCTYPE html&gt;    &lt;head&gt;        &lt;style&gt;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n外联\n在文件的根目录下创建后缀名为.css的文件\n通过&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;*.css&quot; /&gt;来进行外联\n嵌套式\n使用此方法可以再标签中直接添加，例：&lt;p style=&quot;font-size:15;&quot;&gt;&lt;/p&gt;，注：内联每一个属性之间以;隔开\n@import\n@import &quot;*.css&quot;;用来引入CSS文件，使页面呈现出对应的效果\nCSS四种引入样式的区别\n1.行内样式只作用于当前标签。HTML页面不纯净，后期维护不方便。2.内部样式作用于当前文件。CSS 代码写在 HTML 文档中，如果一个网站有很多 HTML 页面，每个文件都会变大，后期维护难度也大，如果 HTML 文件很少，CSS 代码也不多，也可以使用这种方式。3.外部样式可以被多个 HTML 文件引用。实现了 HTML 代码与 CSS 的完全分离，使得前期开发和后期维护都十分方便。\n5.外部样式分为 &lt;link&gt; 引入和@import 引入两种方式。这两种方式的区别为：\n&lt;link&gt; 是 XHTML 标签，除了可以加载 CSS 外，还可以定义 RSS 等其他事务，通过 &lt;link&gt; 标签中的 href=&quot;&quot; 属性来引入外部文件。@import 属于 CSS 范畴，只能加载 CSS ，应该写在 CSS 中，且导入语句应写在样式表的开头，否则无法正确导入外部文件。&lt;link&gt; 引用 CSS 时，在页面载入的时候可以同时加载样式，样式加载和结构加载是异步操作。可以防止访问网页时先加载完文字、图片等结构数据，然后再加载样式的问题。@import 需要网页结构完全载入以后加载样式文件。&lt;link&gt; 是 XHTML 标签，无兼容问题。@import 是在 CSS2.1 提出的，低版本浏览器不支持。&lt;link&gt; 支持使用 JavaScript 控制 DOM 来改变样式。@import 不支持。\n4 种CSS 引用方式的优先级：\n就近原则内部样式、 &lt;link&gt; 链入外部样式表、 @import 导入外部样式表三种方式同时出现在 HTML 页面的 &lt;head&gt;&lt;/head&gt; 标签内时，谁离要修改样式的元素近，谁的优先级高行内样式 &gt; 内部样式、  链入外部样式表、 @import 导入外部样式表\n在实际项目开发中，最好使用外部样式。符合解耦合的开发思想。想要修改某个字体或者样式，直接在 CSS 文件中修改，不需要修改 HTML 结构，页面变得更加容易维护，也有利于提升开发者的工作效率。\n","categories":["前端"],"tags":["前端"]},{"title":"React基础（一）","url":"/2021/11/01/React%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/","content":"React简介1.是什么？React是用于构建用户界面的JavaScript库\n界面-&gt;视图（关注视图）\n1.1 发送请求获取数据\n1.2 处理数据（过滤，整理格式）\n1.3 操作DOM呈现页面\n是一个将数据渲染为HTML试图的开源JavaScript库\n2.谁开发的是由Facebook开发且开源\n3.为什么学React3.1 原生JavaScript操作DOM 繁琐、效率低下（DOM-API操作UI）比如：计时器操作盒子变换颜色\n3.2 使用JavaScript直接操作DOM，浏览器会进行大量的重绘重排。\n3.3原生JavaScript没有组件化编码方案，代码复用率低\n3.3.1组件化 ：html/css/js（一拆到底）\n4.React的特点4.1采用组件化模式、声明式编码,蹄盖哦就开发效率及组件复用率\n4.1.1声明式编码:不用亲历亲为（学习语法）\n4.2在React Native中可以使用React语法进行移动端开发\n4.3使用虚拟DOM+优秀的 Diffing算法，尽量减少与真实DOM进行交互\n5.学习React之前掌握的JavaScript的基础知识5.1判断this的指向\n5.2class（类）\n5.3ES6的语法规范\n5.4npm包管理器\n5.5原型、原型链\n5.6数组常用方法模块化\nReact第一个案例Hello React&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Hello React&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 准备一个容器 --&gt;    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;    &lt;!-- 引入React核心库 --&gt;    &lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dome,用于支持react操作dom --&gt;    &lt;script src=&quot;../js//react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入bable,用于将jsx转化为js --&gt;    &lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- /*此处一定要写bable*/ --&gt;    &lt;script type=&quot;text/babel&quot;&gt;         //写jsx脚本        //创建虚拟dom        const VDOM = &lt;h1&gt;Hello React&lt;/h1&gt; /*此处一定不要写&#x27;&#x27;*/        //渲染虚拟dom到页面        ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)) //参数1 虚拟DOM 参数2 容器    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n虚拟DOM虚拟DOM的两种创建方式JSX&amp;JSJSX更加简单的创建虚拟DOM\nJSX其实就是原始创建虚拟DOM的语法糖，更加便捷\n虚拟DOM与真实DOM关于虚拟DOM：\n​      1.本质上是Object类型的对象（一般对象）\n​      2.虚拟DOM比较‘轻’,真实DOM比较‘重’：因为虚拟DOM是React内部在使用，无需真实DOM上那么多的属性\n​      3.虚拟DOM最终会被React转化为真实DOM呈现在页面之上\nJSXJSX语法规则\n全称：JavaScript XML\n\nReact定义的一种类似于XML的JS扩展语法：JS+XML\n\nXML早期用于存储和传输数据\n\n\n本质是：React.createElement(component，props，….children)\n\n作用：用来简化创建的虚拟DOM：\n\n写法：var ele = &lt;h1&gt;Hello ReactJSX&lt;/h1&gt;\n注意：他不是字符串，也不是HTML/XML标签\n他最终生产的是一个JS对象\n\n\n标签名任意：HTML标签或其他标签\n\n JSX语法规则：\n\n\n   ​      1.定义虚拟DOM不要写‘’\n   ​      2.标签中混入JS表达式时要用{}\n   ​      3.样式的类名指定不能使用class 需要使用className\n   ​      4.内联样式要使用style=&#123;&#123; key:'value' &#125;&#125;这种形式\n   ​      5.虚拟DOM必须只有一个跟标签\n   ​      6.标签必须闭合\n   ​      7.关于标签首字母\n   ​            1）若小写字母开头，则将该标签转为html中的同名标签，若无该标签对应的同名元素，则报错\n   ​            2）若大写字母开头，React就去渲染对应的组件，若组件没有定义，报错\nJSX的小练习   代码      &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;title&gt;JSX的小练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 准备一个容器 --&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;!-- 引入React核心库 --&gt;&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入react-dome,用于支持react操作dom --&gt;&lt;script src=&quot;../js//react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入bable,用于将jsx转化为js --&gt;&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;!-- /*此处一定要写bable*/ --&gt;&lt;script type=&quot;text/babel&quot;&gt;   //1.创建虚拟DOM   const VDOM = (           &lt;div&gt;              &lt;h1&gt;前端框架列表&lt;/h1&gt;              &lt;ul&gt;                 &lt;li&gt;Angulr&lt;/li&gt;                 &lt;li&gt;Angulr&lt;/li&gt;                 &lt;li&gt;Angulr&lt;/li&gt;              &lt;/ul&gt;           &lt;/div&gt;   )   //2.渲染虚拟DOM到页面上   ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;注意：注意区分【js语句（代码）】和【js的表达式】\n  ​  1. 表达式：一个表达式会产生一个值，可以放在需要值的地方\n              下面这些都是表达式：\n                 a\n                 a+b \n                 demo(1)  \n                 arr.map()\n                 function test()&#123;&#125;\n  ​  2. 语句（代码）：\n              下面这些都是语句（代码）\n                 if()&#123;&#125;\n                 for()&#123;&#125;\n                 switch()&#123;case:xxx;&#125;\n\n模块化组件化、模块与组件的理解模块  1.理解：向外提供一个 特定功能的JS程序，一般就是一个JS文件\n  \n  2.为什么要拆分成模块：随着业务逻辑，代码与来越复杂\n\n  3. 作用：复用JS，简化JS的编写，提高JS运行的效率\n\n组件  1. 理解：用来实现局部功能效果代码和资源的集合（HTML/CSS/IMAGE）\n\n  2. 为什么要使用组件：一个界面的功能更复杂，使用组件可以减少这中复杂的情况\n\n  3. 作用：复用编码，简化项目，提高代码运行效率\n\n模块化  当应用的JS都以模块来写的时候，这个应用就是一个模块化的应用\n\n组件化  当应用是以组件的方式实现的时候。这个应用就是一个组件化的应用\n\nReact面向对象的编程基本理解与使用   使用React开发者测试工具调式：React Developer Tools\n注意：  1.组件的首字母大写\n\n  2.虚拟DOM元素有且只能有一个根元素\n\n  3.虚拟DOM元素必需要有结束的标签，又开始有结束\n\n渲染类组件标签的基本流程  1.React内部会创建组件的实例对象\n\n  2.调用render（）得到的虚拟DOM，并解析为真是DOM\n\n  3.插入到指定的页面元素内部\n\n组件的三大核心属性state理解  1.state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）\n\n  2.组件被称为“状态机”，通过更新组件的state来更新对应的页面显示（重新渲染组件）\n\n注意：  1.组件中的render方法中的this为组件的实例对象\n\n  2.组件自定义的方法中的this为undefind\n\n        a.强制绑定this：通过函数对象的bind（）\n\n        b.箭头函数\n\n  3.状态数据，不能直接修改或更新\n\nprops理解：  1.每个组件对象都会有porps（properties的简写）属性\n\n  2.组件标签的所有属性都保存在props中\n\n作用：  1.通过标签属性从组件外向组件内传递变化的数据\n\n  2.注意：组件内部不要修改props的数据\n\n编码操作内部读取某个属性的值  this.props.name\n\n对props中的属性值进行类型限制和必要限制使用prop-types库进限制（需要引入prop-types库）\nPerson.propTypes = &#123;     name: React.propTypes.string.isRequired,    age:React.propTypes.number\n扩展属性：将对象的所有属性值，通过props进行传递\n&lt;Person&#123;....person&#125;/&gt;\n\n默认属性值：\nPerson.defultProps = &#123;    age:1,    sex:&#x27;男&#x27;&#125;\n\n组件类的构造函数\nconstructor(props)&#123;    super(props)    console.log(props)&#125;\n\n","categories":["React"],"tags":["React"]}]